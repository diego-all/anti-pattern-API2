name: Despliegue Continuo a GCE

on:
  push:
    branches:
      - feature/bad-practices
      - feature/hardenized

env:
  PROJECT_ID: rare-lambda-415802
  GCE_ZONE: us-east1-b
  GCE_REGION: us-east1 # Derivado de GCE_ZONE
  GCR_HOSTNAME: gcr.io
  DB_IMAGE_NAME: go-instruments-db
  APP_IMAGE_NAME: go-instruments-app
  APP_PORT: 8080 # Puerto de la aplicación internamente
  GCE_MACHINE_TYPE: e2-micro
  # Las IPs estáticas se definirán por job

jobs:
  deploy-bad-practices:
    name: Desplegar a Instancia de Bad Practices
    if: github.ref == 'refs/heads/feature/bad-practices'
    runs-on: ubuntu-latest
    environment: bad-practices # Opcional: para entornos de despliegue
    env:
      GCE_INSTANCE_NAME: go-vulnerable-app-instance
      GCE_STATIC_IP_NAME: go-vulnerable-app-static-ip
      # Usamos github.sha como tag para las imágenes, asegurando unicidad
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Autenticar a Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}'

      - name: Configurar Docker para GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Construir y etiquetar imagen de la base de datos
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f db/Dockerfile ./db
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Construir y etiquetar imagen de la aplicación
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f Dockerfile .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Obtener dirección IP reservada
        id: get_ip
        run: |
          RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')
          echo "RESERVED_IP=${RESERVED_IP}" >> $GITHUB_ENV

      - name: Verificar y crear instancia de GCE si no existe
        id: create_instance
        run: |
          if ! gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} --project=${{ env.PROJECT_ID }} --zone=${{ env.GCE_ZONE }} &> /dev/null; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                  --project=${{ env.PROJECT_ID }} \
                  --zone=${{ env.GCE_ZONE }} \
                  --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                  --image-family=ubuntu-2204-lts \
                  --image-project=ubuntu-os-cloud \
                  --boot-disk-size=20GB \
                  --boot-disk-type=pd-standard \
                  --tags=http-server,https-server,ssh-go-app \
                  --scopes=https://www.googleapis.com/auth/cloud-platform \
                  --address=${{ env.GCE_STATIC_IP_NAME }} \
                  --network-tier=STANDARD
              echo "Instancia creada. Esperando a que esté lista para SSH..."
              sleep 60 # Dar tiempo para que la instancia inicie y SSH esté disponible
          else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe."
          fi

      - name: Esperar a que SSH esté disponible
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }} # Asegúrate de tener este secreto configurado
          key: ${{ secrets.GCP_SSH_KEY }} # Asegúrate de tener este secreto configurado
          script: |
            echo "Conexión SSH exitosa."
            # Opcional: Puedes agregar un comando simple para verificar la conectividad, e.g., `ls -la`

      - name: Instalar Docker y Docker Compose en la instancia (si no está instalado)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          script: |
            if ! command -v docker &> /dev/null; then
                echo "Instalando Docker..."
                sudo apt-get update
                sudo apt-get install -y ca-certificates curl gnupg
                sudo install -m 0755 -d /etc/apt/keyrings
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                sudo chmod a+r /etc/apt/keyrings/docker.gpg
                echo \
                  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
                  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                sudo apt-get update
                sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                sudo usermod -aG docker $USER
                echo "Docker instalado."
            else
                echo "Docker ya está instalado."
            fi

            if ! command -v docker-compose &> /dev/null; then
                echo "Instalando Docker Compose..."
                # Para la versión 2 de Docker Compose (plugin)
                # Ya debería estar instalado con docker-compose-plugin de la línea anterior
                echo "Docker Compose (plugin) instalado."
            else
                echo "Docker Compose ya está instalado."
            CFI
      - name: Copiar docker-compose.prod.yml y certificados a la instancia
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          source: |
            docker-compose.prod.yml
            cert/cert.pem
            cert/key.pem
          target: /home/${{ secrets.GCP_SSH_USERNAME }}/

      - name: Actualizar docker-compose.prod.yml y desplegar en la instancia
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          script: |
            cd /home/${{ secrets.GCP_SSH_USERNAME }}/
            # Reemplazar el placeholder de la imagen con el tag real
            sed -i "s|__IMAGE_TAG__|${{ env.IMAGE_TAG }}|g" docker-compose.prod.yml
            
            # Autenticar Docker en la instancia con GCR
            # Se asume que la cuenta de servicio de la VM tiene los permisos necesarios para pull de GCR
            # Si no, se necesitaría un paso adicional para autenticar docker en la VM con credenciales.
            # gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet

            echo "Desplegando la aplicación con docker-compose..."
            docker compose -f docker-compose.prod.yml down -v --rmi all
            docker compose -f docker-compose.prod.yml up --build -d
            echo "Despliegue completado."

  deploy-hardenized:
    name: Desplegar a Instancia Hardenized
    if: github.ref == 'refs/heads/feature/hardenized'
    runs-on: ubuntu-latest
    environment: hardenized # Opcional: para entornos de despliegue
    env:
      GCE_INSTANCE_NAME: go-hardenized-app-instance
      GCE_STATIC_IP_NAME: go-hardenized-app-ip
      IMAGE_TAG: ${{ github.sha }} # Usamos github.sha como tag

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Autenticar a Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}'

      - name: Configurar Docker para GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Construir y etiquetar imagen de la base de datos
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f db/Dockerfile ./db
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Construir y etiquetar imagen de la aplicación
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f Dockerfile .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Obtener dirección IP reservada
        id: get_ip
        run: |
          RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')
          echo "RESERVED_IP=${RESERVED_IP}" >> $GITHUB_ENV

      - name: Verificar y crear instancia de GCE si no existe
        id: create_instance
        run: |
          if ! gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} --project=${{ env.PROJECT_ID }} --zone=${{ env.GCE_ZONE }} &> /dev/null; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                  --project=${{ env.PROJECT_ID }} \
                  --zone=${{ env.GCE_ZONE }} \
                  --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                  --image-family=ubuntu-2204-lts \
                  --image-project=ubuntu-os-cloud \
                  --boot-disk-size=20GB \
                  --boot-disk-type=pd-standard \
                  --tags=http-server,https-server,ssh-go-app \
                  --scopes=https://www.googleapis.com/auth/cloud-platform \
                  --address=${{ env.GCE_STATIC_IP_NAME }} \
                  --network-tier=STANDARD
              echo "Instancia creada. Esperando a que esté lista para SSH..."
              sleep 60 # Dar tiempo para que la instancia inicie y SSH esté disponible
          else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe."
          fi

      - name: Esperar a que SSH esté disponible
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          script: |
            echo "Conexión SSH exitosa."

      - name: Instalar Docker y Docker Compose en la instancia (si no está instalado)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          script: |
            if ! command -v docker &> /dev/null; then
                echo "Instalando Docker..."
                sudo apt-get update
                sudo apt-get install -y ca-certificates curl gnupg
                sudo install -m 0755 -d /etc/apt/keyrings
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                sudo chmod a+r /etc/apt/keyrings/docker.gpg
                echo \
                  "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                  "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
                  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                sudo apt-get update
                sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                sudo usermod -aG docker $USER
                echo "Docker instalado."
            else
                echo "Docker ya está instalado."
            fi

            if ! command -v docker-compose &> /dev/null; then
                echo "Instalando Docker Compose..."
                echo "Docker Compose (plugin) instalado."
            else
                echo "Docker Compose ya está instalado."
            fi

      - name: Copiar docker-compose.prod.yml y certificados a la instancia
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          source: |
            docker-compose.prod.yml
            cert/cert.pem
            cert/key.pem
          target: /home/${{ secrets.GCP_SSH_USERNAME }}/

      - name: Actualizar docker-compose.prod.yml y desplegar en la instancia
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RESERVED_IP }}
          username: ${{ secrets.GCP_SSH_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          script: |
            cd /home/${{ secrets.GCP_SSH_USERNAME }}/
            sed -i "s|__IMAGE_TAG__|${{ env.IMAGE_TAG }}|g" docker-compose.prod.yml
            
            echo "Desplegando la aplicación con docker-compose..."
            docker compose -f docker-compose.prod.yml down -v --rmi all
            docker compose -f docker-compose.prod.yml up --build -d
            echo "Despliegue completado."