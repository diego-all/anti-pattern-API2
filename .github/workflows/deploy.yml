name: Deploy Go App to GCE and Prepare for DAST

on:
  push:
    branches:
      - main
      - feature/bad-practices
      - feature/hardenized # Agregamos la nueva rama de despliegue

env:
  PROJECT_ID: rare-lambda-415802
  GCE_ZONE: us-east1-b # La zona puede ser la misma para ambas instancias
  GCE_REGION: us-east1 # Define la región para operaciones de IP estática
  GCR_HOSTNAME: gcr.io
  DB_IMAGE_NAME: go-instruments-db
  APP_IMAGE_NAME: go-instruments-app
  APP_PORT: 8080 # Puerto de la aplicación internamente
  GCE_MACHINE_TYPE: e2-micro # Tipo de máquina deseado: Ahora es global y se aplica a ambas instancias

jobs:
  # Job para la rama "bad-practices" (y main)
  deploy-bad-practices:
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feature/bad-practices'
    runs-on: ubuntu-latest
    environment: production # Puedes crear un ambiente "bad-practices" si quieres control granular
    env: # Variables específicas para este job, GCE_MACHINE_TYPE se hereda del env global
      GCE_INSTANCE_NAME: go-vulnerable-app-instance
      GCE_STATIC_IP_NAME: go-vulnerable-app-static-ip

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate Google Cloud Service Account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Authorize Docker to GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Build and push DB Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}" -f db/Dockerfile db/
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Build and push App Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}" .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Create or update GCE instance for Bad Practices
        id: create-gce-bad-practices
        run: |
          # DEBUG: Muestra el tipo de máquina deseado
          echo "DEBUG: Tipo de máquina deseado para '${{ env.GCE_INSTANCE_NAME }}': ${{ env.GCE_MACHINE_TYPE }}"

          INSTANCE_EXISTS=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                            --zone=${{ env.GCE_ZONE }} \
                            --project=${{ env.PROJECT_ID }} &> /dev/null; echo $?)

          # Script de inicio para la instancia GCE
          # Se asegura de que docker-compose esté en el PATH y el usuario tenga permisos
          STARTUP_SCRIPT="#! /bin/bash
            # Actualizar e instalar Docker y Docker Compose
            sudo apt-get update && sudo apt-get install -y docker.io docker-compose-v2

            # Añadir el usuario actual al grupo docker para evitar usar sudo con docker
            sudo usermod -aG docker \$(whoami)

            # Dar permisos al socket de Docker (precaución: para entornos de desarrollo/pruebas)
            sudo chmod 666 /var/run/docker.sock

            # Reiniciar el servicio Docker para aplicar los cambios (opcional, pero puede ayudar)
            sudo systemctl restart docker

            # Exportar la ruta de docker compose v2 para que sea accesible sin 'docker compose'
            # y se añada al PATH para futuras sesiones ssh del usuario que ejecuta el startup script
            echo 'export PATH=\"\$PATH:/usr/local/bin\"' | sudo tee -a /etc/profile
            echo 'Docker y Docker Compose instalados y configurados.'
          "
          
          if [ "$INSTANCE_EXISTS" -ne 0 ]; then
            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
            gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
              --project=${{ env.PROJECT_ID }} \
              --zone=${{ env.GCE_ZONE }} \
              --machine-type=${{ env.GCE_MACHINE_TYPE }} \
              --image-family=ubuntu-2204-lts \
              --image-project=ubuntu-os-cloud \
              --boot-disk-size=20GB \
              --boot-disk-type=pd-standard \
              --tags=http-server,https-server,ssh-go-app \
              --scopes=https://www.googleapis.com/auth/cloud-platform \
              --address=${{ env.GCE_STATIC_IP_NAME }} \
              --metadata-from-file=startup-script=<(echo "$STARTUP_SCRIPT") # Usamos metadata-from-file
            sleep 90 # Aumentar el tiempo de espera inicial para que el startup-script termine
          else
            CURRENT_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
            # Extrae solo el nombre del tipo de máquina (ej. e2-micro)
            CURRENT_MACHINE_TYPE=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                                    --zone=${{ env.GCE_ZONE }} \
                                    --project=${{ env.PROJECT_ID }} \
                                    --format='get(machineType)' | awk -F/ '{print $NF}')

            RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')

            # DEBUG: Muestra la IP actual y la IP reservada
            echo "DEBUG: IP actual de '${{ env.GCE_INSTANCE_NAME }}': ${CURRENT_IP}, IP reservada: ${RESERVED_IP}"
            # DEBUG: Muestra el tipo de máquina actual y el tipo de máquina deseado
            echo "DEBUG: Tipo de máquina actual de '${{ env.GCE_INSTANCE_NAME }}': ${CURRENT_MACHINE_TYPE}, Tipo deseado: ${{ env.GCE_MACHINE_TYPE }}"

            # Recrear si la IP no coincide O si el tipo de máquina no coincide
            if [ "$CURRENT_IP" != "$RESERVED_IP" ] || [ "$CURRENT_MACHINE_TYPE" != "${{ env.GCE_MACHINE_TYPE }}" ]; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' existe pero su IP (${CURRENT_IP} vs ${RESERVED_IP}) o tipo de máquina (${CURRENT_MACHINE_TYPE} vs ${{ env.GCE_MACHINE_TYPE }}) no coinciden. Deteniendo y recreando."
              gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances delete ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                --project=${{ env.PROJECT_ID }} \
                --zone=${{ env.GCE_ZONE }} \
                --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                --image-family=ubuntu-2204-lts \
                --image-project=ubuntu-os-cloud \
                --boot-disk-size=20GB \
                --boot-disk-type=pd-standard \
                --tags=http-server,https-server,ssh-go-app \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                --address=${{ env.GCE_STATIC_IP_NAME }} \
                --metadata-from-file=startup-script=<(echo "$STARTUP_SCRIPT") # Usamos metadata-from-file
              sleep 90 # Aumentar el tiempo de espera inicial para que el startup-script termine
            else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe, tiene la IP estática asignada y el tipo de máquina correcto. Reiniciando para aplicar cambios."
              gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
              sleep 10
              gcloud compute instances start ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 60
            fi
          fi
          
          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            # Agregamos 'exit 0' para asegurar que el comando SSH termina correctamente incluso si 'echo' no produce salida
            if gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --command="echo 'Instancia SSH lista.' && exit 0" --quiet; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

          PUBLIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "::notice file=README.md::IP pública de la aplicación Bad Practices: $PUBLIC_IP"

      - name: Copy docker-compose.prod.yml and Deploy
        run: |
          IMAGE_TAG="${{ github.sha }}"
          gcloud compute scp docker-compose.prod.yml cert/cert.pem cert/key.pem ${{ env.GCE_INSTANCE_NAME }}:~/ \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --recurse

          gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --command="
              cd ~/ && \
              # Espera para que el startup-script y los cambios de PATH se apliquen completamente
              # y Docker esté listo para aceptar comandos.
              sleep 45 && \
              # Asegura que el PATH incluye /usr/local/bin para docker compose v2
              export PATH=\"\$PATH:/usr/local/bin\" && \
              # Intenta recargar el perfil solo si no está en un shell interactivo (para evitar errores)
              [[ \$- == *i* ]] || source /etc/profile || source ~/.profile || true && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              sed -i 's|__IMAGE_TAG__|${IMAGE_TAG}|g' docker-compose.prod.yml && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
            "

      - name: Verify application deployment (Bad Practices)
        run: |
          echo "Esperando que la aplicación Go (Bad Practices) se inicie en https://${{ env.PUBLIC_IP }}:80..."
          sleep 60
          # Usamos --retry para mayor robustez
          curl -f -k --retry 5 --retry-delay 10 https://${{ env.PUBLIC_IP }}:80/instruments || \
            (echo "La aplicación no respondió en el tiempo esperado." && exit 1)
          echo "Aplicación Go (Bad Practices) desplegada y accesible en https://${{ env.PUBLIC_IP }}:80"


  # Job para la rama "hardenized"
  deploy-hardenized:
    if: github.ref == 'refs/heads/feature/hardenized'
    runs-on: ubuntu-latest
    environment: hardened # Puedes crear un ambiente "hardenized" para distinguir en GitHub
    env: # Variables específicas para este job, GCE_MACHINE_TYPE se hereda del env global
      GCE_INSTANCE_NAME: go-hardenized-app-instance # Nuevo nombre de instancia
      GCE_STATIC_IP_NAME: go-hardenized-app-ip

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate Google Cloud Service Account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Authorize Docker to GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Build and push DB Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}" -f db/Dockerfile db/
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Build and push App Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}" .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Create or update GCE instance for Hardenized
        id: create-gce-hardenized
        run: |
          # DEBUG: Muestra el tipo de máquina deseado
          echo "DEBUG: Tipo de máquina deseado para '${{ env.GCE_INSTANCE_NAME }}': ${{ env.GCE_MACHINE_TYPE }}"

          INSTANCE_EXISTS=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                            --zone=${{ env.GCE_ZONE }} \
                            --project=${{ env.PROJECT_ID }} &> /dev/null; echo $?)

          # Script de inicio para la instancia GCE
          # Se asegura de que docker-compose esté en el PATH y el usuario tenga permisos
          STARTUP_SCRIPT="#! /bin/bash
            # Actualizar e instalar Docker y Docker Compose
            sudo apt-get update && sudo apt-get install -y docker.io docker-compose-v2

            # Añadir el usuario actual al grupo docker para evitar usar sudo con docker
            sudo usermod -aG docker \$(whoami)

            # Dar permisos al socket de Docker (precaución: para entornos de desarrollo/pruebas)
            sudo chmod 666 /var/run/docker.sock

            # Reiniciar el servicio Docker para aplicar los cambios (opcional, pero puede ayudar)
            sudo systemctl restart docker

            # Exportar la ruta de docker compose v2 para que sea accesible sin 'docker compose'
            # y se añada al PATH para futuras sesiones ssh del usuario que ejecuta el startup script
            echo 'export PATH=\"\$PATH:/usr/local/bin\"' | sudo tee -a /etc/profile
            echo 'Docker y Docker Compose instalados y configurados.'
          "

          if [ "$INSTANCE_EXISTS" -ne 0 ]; then
            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
            gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
              --project=${{ env.PROJECT_ID }} \
              --zone=${{ env.GCE_ZONE }} \
              --machine-type=${{ env.GCE_MACHINE_TYPE }} \
              --image-family=ubuntu-2204-lts \
              --image-project=ubuntu-os-cloud \
              --boot-disk-size=20GB \
              --boot-disk-type=pd-standard \
              --tags=http-server,https-server,ssh-go-app \
              --scopes=https://www.googleapis.com/auth/cloud-platform \
              --address=${{ env.GCE_STATIC_IP_NAME }} \
              --network-tier=STANDARD \
              --metadata-from-file=startup-script=<(echo "$STARTUP_SCRIPT") # Usamos metadata-from-file
            sleep 90 # Aumentar el tiempo de espera inicial para que el startup-script termine
          else
            CURRENT_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
            # Extrae solo el nombre del tipo de máquina (ej. e2-micro)
            CURRENT_MACHINE_TYPE=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                                    --zone=${{ env.GCE_ZONE }} \
                                    --project=${{ env.PROJECT_ID }} \
                                    --format='get(machineType)' | awk -F/ '{print $NF}')

            RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')

            # DEBUG: Muestra la IP actual y la IP reservada
            echo "DEBUG: IP actual de '${{ env.GCE_INSTANCE_NAME }}': ${CURRENT_IP}, IP reservada: ${RESERVED_IP}"
            # DEBUG: Muestra el tipo de máquina actual y el tipo de máquina deseado
            echo "DEBUG: Tipo de máquina actual de '${{ env.GCE_INSTANCE_NAME }}': ${CURRENT_MACHINE_TYPE}, Tipo deseado: ${{ env.GCE_MACHINE_TYPE }}"


            if [ "$CURRENT_IP" != "$RESERVED_IP" ] || [ "$CURRENT_MACHINE_TYPE" != "${{ env.GCE_MACHINE_TYPE }}" ]; then
              # Recrear si la IP no coincide O si el tipo de máquina no coincide
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' existe pero su IP (${CURRENT_IP} vs ${RESERVED_IP}) o tipo de máquina (${CURRENT_MACHINE_TYPE} vs ${{ env.GCE_MACHINE_TYPE }}) no coinciden. Deteniendo y recreando."
              gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances delete ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                --project=${{ env.PROJECT_ID }} \
                --zone=${{ env.GCE_ZONE }} \
                --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                --image-family=ubuntu-2204-lts \
                --image-project=ubuntu-os-cloud \
                --boot-disk-size=20GB \
                --boot-disk-type=pd-standard \
                --tags=http-server,https-server,ssh-go-app \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                --address=${{ env.GCE_STATIC_IP_NAME }} \
                --network-tier=STANDARD \
                --metadata-from-file=startup-script=<(echo "$STARTUP_SCRIPT") # Usamos metadata-from-file
              sleep 90 # Aumentar el tiempo de espera inicial para que el startup-script termine
            else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe, tiene la IP estática asignada y el tipo de máquina correcto. Reiniciando para aplicar cambios."
              gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
              sleep 10
              gcloud compute instances start ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 60
            fi
          fi
          
          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            # Agregamos 'exit 0' para asegurar que el comando SSH termina correctamente incluso si 'echo' no produce salida
            if gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --command="echo 'Instancia SSH lista.' && exit 0" --quiet; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

          PUBLIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "::notice file=README.md::IP pública de la aplicación Hardenized: $PUBLIC_IP"

      - name: Copy docker-compose.prod.yml and Deploy
        run: |
          IMAGE_TAG="${{ github.sha }}"
          gcloud compute scp docker-compose.prod.yml cert/cert.pem cert/key.pem ${{ env.GCE_INSTANCE_NAME }}:~/ \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --recurse

          gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --command="
              cd ~/ && \
              # Espera para que el startup-script y los cambios de PATH se apliquen completamente
              # y Docker esté listo para aceptar comandos.
              sleep 45 && \
              # Asegura que el PATH incluye /usr/local/bin para docker compose v2
              export PATH=\"\$PATH:/usr/local/bin\" && \
              # Intenta recargar el perfil solo si no está en un shell interactivo (para evitar errores)
              [[ \$- == *i* ]] || source /etc/profile || source ~/.profile || true && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              sed -i 's|__IMAGE_TAG__|${IMAGE_TAG}|g' docker-compose.prod.yml && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
            "

      - name: Verify application deployment (Hardenized)
        run: |
          echo "Esperando que la aplicación Go (Hardenized) se inicie en https://${{ env.PUBLIC_IP }}:80..."
          sleep 60
          # Usamos --retry para mayor robustez
          curl -f -k --retry 5 --retry-delay 10 https://${{ env.PUBLIC_IP }}:80/instruments || \
            (echo "La aplicación no respondió en el tiempo esperado." && exit 1)
          echo "Aplicación Go (Hardenized) desplegada y accesible en https://${{ env.PUBLIC_IP }}:80"