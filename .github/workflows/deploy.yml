name: Deploy Go App to GCE and Prepare for DAST

on:
  push:
    branches:
      - main
      - feature/bad-practices
      - feature/hardenized # Agregamos la nueva rama de despliegue

env:
  PROJECT_ID: rare-lambda-415802
  GCE_ZONE: us-east1-b # La zona puede ser la misma para ambas instancias
  GCR_HOSTNAME: gcr.io
  DB_IMAGE_NAME: go-instruments-db
  APP_IMAGE_NAME: go-instruments-app
  APP_PORT: 8080 # Puerto de la aplicación internamente

jobs:
  # Job para la rama "bad-practices" (y main) - usando e2-medium
  deploy-bad-practices:
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feature/bad-practices'
    runs-on: ubuntu-latest
    environment: production # Puedes crear un ambiente "bad-practices" si quieres control granular
    env: # Variables específicas para este job
      GCE_INSTANCE_NAME: go-vulnerable-app-instance
      GCE_MACHINE_TYPE: e2-small # Tipo de máquina para el ambiente vulnerable
      # Asegúrate de haber reservado 'go-vulnerable-app-static-ip' en GCP
      GCE_STATIC_IP_NAME: go-vulnerable-app-static-ip

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate Google Cloud Service Account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Authorize Docker to GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Build and push DB Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}" -f db/Dockerfile db/
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Build and push App Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}" .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Create or update GCE instance for Bad Practices
        id: create-gce-bad-practices
        run: |
          # Verificar si la instancia ya tiene la IP estática asignada
          HAS_STATIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')

          # Si la instancia no existe o su IP actual no es la estática, la creamos/reiniciamos con la IP estática
          if ! gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} &> /dev/null || \
             [ "$HAS_STATIC_IP" != "$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} --region=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --format='value(address)')" ]; then

            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe o su IP no es la estática. Creando/Reiniciando para aplicar cambios."
            # Si la instancia ya existe, la detenemos antes de intentar cambiar su IP
            gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
            sleep 10 # Pequeña espera para asegurar que el comando de stop se registre

            # Comando de creación o reinicio de instancia, asegurando la asignación de la IP estática
            gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
              --project=${{ env.PROJECT_ID }} \
              --zone=${{ env.GCE_ZONE }} \
              --machine-type=${{ env.GCE_MACHINE_TYPE }} \
              --image-family=ubuntu-2204-lts \
              --image-project=ubuntu-os-cloud \
              --boot-disk-size=20GB \
              --boot-disk-type=pd-standard \
              --tags=http-server,https-server,ssh-go-app \
              --scopes=https://www.googleapis.com/auth/cloud-platform \
              --address=${{ env.GCE_STATIC_IP_NAME }} \
              --metadata=startup-script="#! /bin/bash
                sudo apt-get update && sudo apt-get install -y docker.io docker-compose-v2
                sudo usermod -aG docker \$(whoami)
                sudo chmod 666 /var/run/docker.sock
                echo 'Docker y Docker Compose instalados.'
                "
            sleep 60 # Dar tiempo a la VM y Docker para arrancar y el startup-script para ejecutarse
          else
            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe y tiene la IP estática asignada. Reiniciando para aplicar cambios."
            gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
            sleep 10 # Pequeña espera para asegurar que el comando de stop se registre
            gcloud compute instances start ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
            sleep 60 # Dar tiempo a la VM y Docker para arrancar y el startup-script para ejecutarse
          fi

          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            if gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --command="echo 'Instancia SSH lista.'" --quiet; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

          PUBLIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "::notice file=README.md::IP pública de la aplicación Bad Practices: $PUBLIC_IP"

      - name: Copy docker-compose.prod.yml and Deploy
        run: |
          IMAGE_TAG="${{ github.sha }}"
          gcloud compute scp docker-compose.prod.yml cert.pem key.pem ${{ env.GCE_INSTANCE_NAME }}:~/ \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --recurse

          gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --command="
              cd ~/ && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              sed -i 's|__IMAGE_TAG__|${IMAGE_TAG}|g' docker-compose.prod.yml && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
            "

      - name: Verify application deployment (Bad Practices)
        run: |
          echo "Esperando que la aplicación Go (Bad Practices) se inicie en https://${{ env.PUBLIC_IP }}:80..."
          sleep 60
          curl -f -k https://${{ env.PUBLIC_IP }}:80/instruments || \
            (echo "La aplicación no respondió en el tiempo esperado." && exit 1)
          echo "Aplicación Go (Bad Practices) desplegada y accesible en https://${{ env.PUBLIC_IP }}:80"

  # Nuevo Job para la rama "hardenized" - usando e2-small
  deploy-hardenized:
    if: github.ref == 'refs/heads/feature/hardenized'
    runs-on: ubuntu-latest
    environment: hardened # Puedes crear un ambiente "hardenized" para distinguir en GitHub
    env: # Variables específicas para este job
      GCE_INSTANCE_NAME: go-hardenized-app-instance # Nuevo nombre de instancia
      GCE_MACHINE_TYPE: e2-small # Tipo de máquina más económico
      # Asegúrate de haber reservado 'go-hardenized-app-ip' en GCP
      GCE_STATIC_IP_NAME: go-hardenized-app-ip

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate Google Cloud Service Account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Authorize Docker to GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Build and push DB Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}" -f db/Dockerfile db/
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Build and push App Docker image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}" .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:"${IMAGE_TAG}"

      - name: Create or update GCE instance for Hardenized
        id: create-gce-hardenized
        run: |
          # Verificar si la instancia ya tiene la IP estática asignada
          HAS_STATIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')

          # Si la instancia no existe o su IP actual no es la estática, la creamos/reiniciamos con la IP estática
          if ! gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} &> /dev/null || \
             [ "$HAS_STATIC_IP" != "$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} --region=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --format='value(address)')" ]; then

            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe o su IP no es la estática. Creando/Reiniciando para aplicar cambios."
            # Si la instancia ya existe, la detenemos antes de intentar cambiar su IP
            gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
            sleep 10 # Pequeña espera para asegurar que el comando de stop se registre

            # Comando de creación o reinicio de instancia, asegurando la asignación de la IP estática
            gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
              --project=${{ env.PROJECT_ID }} \
              --zone=${{ env.GCE_ZONE }} \
              --machine-type=${{ env.GCE_MACHINE_TYPE }} \
              --image-family=ubuntu-2204-lts \
              --image-project=ubuntu-os-cloud \
              --boot-disk-size=20GB \
              --boot-disk-type=pd-standard \
              --tags=http-server,https-server,ssh-go-app \
              --scopes=https://www.googleapis.com/auth/cloud-platform \
              --address=${{ env.GCE_STATIC_IP_NAME }} \
              --metadata=startup-script="#! /bin/bash
                sudo apt-get update && sudo apt-get install -y docker.io docker-compose-v2
                sudo usermod -aG docker \$(whoami)
                sudo chmod 666 /var/run/docker.sock
                echo 'Docker y Docker Compose instalados.'
                "
            sleep 60
          else
            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe y tiene la IP estática asignada. Reiniciando para aplicar cambios."
            gcloud compute instances stop ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet || true
            sleep 10 # Pequeña espera para asegurar que el comando de stop se registre
            gcloud compute instances start ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
            sleep 60
          fi
          
          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            if gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --command="echo 'Instancia SSH lista.'" --quiet; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

          PUBLIC_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "::notice file=README.md::IP pública de la aplicación Hardenized: $PUBLIC_IP"

      - name: Copy docker-compose.prod.yml and Deploy
        run: |
          IMAGE_TAG="${{ github.sha }}"
          gcloud compute scp docker-compose.prod.yml cert.pem key.pem ${{ env.GCE_INSTANCE_NAME }}:~/ \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --recurse

          gcloud compute ssh ${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --command="
              cd ~/ && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              sed -i 's|__IMAGE_TAG__|${IMAGE_TAG}|g' docker-compose.prod.yml && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
            "

      - name: Verify application deployment (Hardenized)
        run: |
          echo "Esperando que la aplicación Go (Hardenized) se inicie en https://${{ env.PUBLIC_IP }}:80..."
          sleep 60
          curl -f -k https://${{ env.PUBLIC_IP }}:80/instruments || \
            (echo "La aplicación no respondió en el tiempo esperado." && exit 1)
          echo "Aplicación Go (Hardenized) desplegada y accesible en https://${{ env.PUBLIC_IP }}:80"