name: Despliegue Continuo a GCE

on:
  push:
    branches:
      - feature/bad-practices
      - feature/hardenized

env:
  PROJECT_ID: rare-lambda-415802
  GCE_ZONE: us-east1-b
  GCE_REGION: us-east1 # Región para las IPs estáticas
  GCR_HOSTNAME: gcr.io
  DB_IMAGE_NAME: go-instruments-db
  APP_IMAGE_NAME: go-instruments-app
  APP_PORT: 8080 # Puerto de la aplicación internamente
  GCE_MACHINE_TYPE: e2-micro
  # Las IPs estáticas se definirán por job

jobs:
  deploy-bad-practices:
    name: Desplegar a Instancia de Bad Practices
    if: github.ref == 'refs/heads/feature/bad-practices'
    runs-on: ubuntu-latest
    environment: bad-practices # Opcional: para entornos de despliegue
    env:
      GCE_INSTANCE_NAME: go-vulnerable-app-instance
      GCE_STATIC_IP_NAME: go-vulnerable-app-static-ip
      IMAGE_TAG: ${{ github.sha }} # Usamos github.sha como tag para las imágenes
      SSH_USER: daposadalpractices # Definir SSH_USER como variable de entorno del job

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Autenticar a Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}'

      - name: Configurar Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configurar Docker para GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Construir y etiquetar imagen de la base de datos
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f db/Dockerfile ./db
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Construir y etiquetar imagen de la aplicación
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f Dockerfile .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Obtener dirección IP reservada y verificar/crear instancia de GCE
        run: |
          RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')
          echo "RESERVED_IP=${RESERVED_IP}" >> $GITHUB_ENV
          echo "La IP de la instancia ${{ env.GCE_INSTANCE_NAME }} es: $RESERVED_IP"

          INSTANCE_EXISTS=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                            --zone=${{ env.GCE_ZONE }} \
                            --project=${{ env.PROJECT_ID }} &> /dev/null; echo $?)

          if [ "$INSTANCE_EXISTS" -ne 0 ]; then
            echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
            gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                --project=${{ env.PROJECT_ID }} \
                --zone=${{ env.GCE_ZONE }} \
                --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                --image-family=ubuntu-2204-lts \
                --image-project=ubuntu-os-cloud \
                --boot-disk-size=20GB \
                --boot-disk-type=pd-standard \
                --tags=http-server,https-server,ssh-go-app \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                --address=${{ env.GCE_STATIC_IP_NAME }} \
                --network-tier=STANDARD
            echo "Instancia creada. Esperando a que esté lista para SSH..."
            sleep 30 # Tiempo inicial para que la instancia arranque
          else
            CURRENT_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
            if [ "$CURRENT_IP" != "$RESERVED_IP" ]; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' existe pero su IP no es la estática esperada. Recreando."
              gcloud compute instances delete ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                --project=${{ env.PROJECT_ID }} \
                --zone=${{ env.GCE_ZONE }} \
                --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                --image-family=ubuntu-2204-lts \
                --image-project=ubuntu-os-cloud \
                --boot-disk-size=20GB \
                --boot-disk-type=pd-standard \
                --tags=http-server,https-server,ssh-go-app \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                --address=${{ env.GCE_STATIC_IP_NAME }} \
                --network-tier=STANDARD
              sleep 30 # Tiempo inicial para que la instancia arranque
            else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe y tiene la IP estática asignada."
            fi
          fi
          
          echo "Configurando SSH para gcloud..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20 # Segundos entre reintentos

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            if gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
                --zone=${{ env.GCE_ZONE }} \
                --project=${{ env.PROJECT_ID }} \
                --command="echo 'Instancia SSH lista.'" \
                --quiet \
                --ssh-flag="-o StrictHostKeyChecking=no" \
                --ssh-flag="-o UserKnownHostsFile=/dev/null"; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

      - name: Instalar Docker y Docker Compose en la instancia (si no está instalado)
        run: |
          gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --ssh-flag="-o StrictHostKeyChecking=no" \
            --ssh-flag="-o UserKnownHostsFile=/dev/null" \
            --command="
              echo 'Verificando e instalando Docker y Docker Compose si es necesario...'
              if ! command -v docker &> /dev/null; then
                  echo 'Instalando Docker...'
                  sudo apt-get update
                  sudo apt-get install -y ca-certificates curl gnupg lsb-release
                  sudo mkdir -p /etc/apt/keyrings
                  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                  echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                  sudo apt-get update
                  sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                  echo 'Docker instalado.'
              else
                  echo 'Docker ya está instalado.'
              fi
              # Docker Compose v2 (plugin) se instala con docker-compose-plugin
              if ! command -v docker compose &> /dev/null; then
                  echo 'Docker Compose (plugin) no encontrado, verificando instalación de docker-compose-plugin.'
                  sudo apt-get install -y docker-compose-plugin # Asegurarse de que esté instalado
              fi
              # Asegurarse de que el usuario pueda ejecutar comandos docker sin sudo
              sudo usermod -aG docker \$(whoami) || true
              newgrp docker || true # Para aplicar cambios de grupo inmediatamente en la misma sesión SSH
              echo 'Instalación de Docker/Docker Compose completada.'
            "

      - name: Copiar docker-compose.prod.yml y certificados a la instancia
        run: |
          # Se eliminan los flags SSH explícitos para gcloud compute scp,
          # ya que gcloud compute config-ssh debería manejar la configuración SSH.
          # También se eliminó la duplicación del comando.
          gcloud compute scp docker-compose.prod.yml cert/ \
                              ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }}:~/ \
                              --zone=${{ env.GCE_ZONE }} \
                              --project=${{ env.PROJECT_ID }} \
                              --recurse
          echo "Archivos copiados a la instancia."

      - name: Actualizar docker-compose.prod.yml y desplegar en la instancia
        run: |
          gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --ssh-flag="-o StrictHostKeyChecking=no" \
            --ssh-flag="-o UserKnownHostsFile=/dev/null" \
            --command="
              cd ~/ && \
              sed -i \"s|__IMAGE_TAG__|${{ env.IMAGE_TAG }}|g\" docker-compose.prod.yml && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              echo 'Desplegando la aplicación con docker compose...'
              docker compose -f docker-compose.prod.yml down -v --rmi all || true && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
              echo 'Despliegue completado.'
            "

  deploy-hardenized:
    name: Desplegar a Instancia Hardenized
    if: github.ref == 'refs/heads/feature/hardenized'
    runs-on: ubuntu-latest
    environment: hardenized # Opcional: para entornos de despliegue
    env:
      GCE_INSTANCE_NAME: go-hardenized-app-instance
      GCE_STATIC_IP_NAME: go-hardenized-app-ip
      IMAGE_TAG: ${{ github.sha }} # Usamos github.sha como tag
      SSH_USER: daposadalpractices # Definir SSH_USER como variable de entorno del job

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Autenticar a Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}'

      - name: Configurar Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configurar Docker para GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: Construir y etiquetar imagen de la base de datos
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f db/Dockerfile ./db
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.DB_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Construir y etiquetar imagen de la aplicación
        run: |
          docker build -t ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }} -f Dockerfile .
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.APP_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Obtener dirección IP reservada y verificar/crear instancia de GCE
        run: |
          RESERVED_IP=$(gcloud compute addresses describe ${{ env.GCE_STATIC_IP_NAME }} \
                           --region=${{ env.GCE_REGION }} \
                           --project=${{ env.PROJECT_ID }} \
                           --format='value(address)')
          echo "RESERVED_IP=${RESERVED_IP}" >> $GITHUB_ENV
          echo "La IP de la instancia ${{ env.GCE_INSTANCE_NAME }} es: $RESERVED_IP"

          INSTANCE_EXISTS=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                            --zone=${{ env.GCE_ZONE }} \
                            --project=${{ env.PROJECT_ID }} &> /dev/null; echo $?)

          if [ "$INSTANCE_EXISTS" -ne 0 ]; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' no existe. Creando nueva instancia con IP estática."
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                  --project=${{ env.PROJECT_ID }} \
                  --zone=${{ env.GCE_ZONE }} \
                  --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                  --image-family=ubuntu-2204-lts \
                  --image-project=ubuntu-os-cloud \
                  --boot-disk-size=20GB \
                  --boot-disk-type=pd-standard \
                  --tags=http-server,https-server,ssh-go-app \
                  --scopes=https://www.googleapis.com/auth/cloud-platform \
                  --address=${{ env.GCE_STATIC_IP_NAME }} \
                  --network-tier=STANDARD
              echo "Instancia creada. Esperando a que esté lista para SSH..."
              sleep 30 # Dar tiempo para que la instancia inicie y SSH esté disponible
          else
            CURRENT_IP=$(gcloud compute instances describe ${{ env.GCE_INSTANCE_NAME }} \
                          --zone=${{ env.GCE_ZONE }} \
                          --project=${{ env.PROJECT_ID }} \
                          --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
            if [ "$CURRENT_IP" != "$RESERVED_IP" ]; then
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' existe pero su IP no es la estática esperada. Recreando."
              gcloud compute instances delete ${{ env.GCE_INSTANCE_NAME }} --zone=${{ env.GCE_ZONE }} --project=${{ env.PROJECT_ID }} --quiet
              sleep 10
              gcloud compute instances create ${{ env.GCE_INSTANCE_NAME }} \
                --project=${{ env.PROJECT_ID }} \
                --zone=${{ env.GCE_ZONE }} \
                --machine-type=${{ env.GCE_MACHINE_TYPE }} \
                --image-family=ubuntu-2204-lts \
                --image-project=ubuntu-os-cloud \
                --boot-disk-size=20GB \
                --boot-disk-type=pd-standard \
                --tags=http-server,https-server,ssh-go-app \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                --address=${{ env.GCE_STATIC_IP_NAME }} \
                --network-tier=STANDARD
              sleep 30 # Tiempo inicial para que la instancia arranque
            else
              echo "Instancia '${{ env.GCE_INSTANCE_NAME }}' ya existe y tiene la IP estática asignada."
            fi
          fi
          
          echo "Configurando SSH para gcloud..."
          gcloud compute config-ssh --quiet --project=${{ env.PROJECT_ID }}

          echo "Esperando que la instancia GCE '${{ env.GCE_INSTANCE_NAME }}' esté lista para SSH..."
          ATTEMPTS=0
          MAX_ATTEMPTS=15
          SLEEP_TIME=20 # Segundos entre reintentos

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            echo "Intento $((ATTEMPTS + 1)) de $MAX_ATTEMPTS: Probando conexión SSH..."
            if gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
                --zone=${{ env.GCE_ZONE }} \
                --project=${{ env.PROJECT_ID }} \
                --command="echo 'Instancia SSH lista.'" \
                --quiet \
                --ssh-flag="-o StrictHostKeyChecking=no" \
                --ssh-flag="-o UserKnownHostsFile=/dev/null"; then
              echo "Conexión SSH exitosa."
              break
            else
              echo "Fallo al conectar SSH. Reintentando en ${SLEEP_TIME} segundos..."
              ATTEMPTS=$((ATTEMPTS + 1))
              sleep $SLEEP_TIME
            fi
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Fallo al conectar SSH después de $MAX_ATTEMPTS intentos. La instancia podría no estar accesible."
            exit 1
          fi

      - name: Instalar Docker y Docker Compose en la instancia (si no está instalado)
        run: |
          gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --ssh-flag="-o StrictHostKeyChecking=no" \
            --ssh-flag="-o UserKnownHostsFile=/dev/null" \
            --command="
              echo 'Verificando e instalando Docker y Docker Compose si es necesario...'
              if ! command -v docker &> /dev/null; then
                  echo 'Instalando Docker...'
                  sudo apt-get update
                  sudo apt-get install -y ca-certificates curl gnupg lsb-release
                  sudo mkdir -p /etc/apt/keyrings
                  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                  echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                  sudo apt-get update
                  sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                  echo 'Docker instalado.'
              else
                  echo 'Docker ya está instalado.'
              fi
              if ! command -v docker compose &> /dev/null; then
                  echo 'Docker Compose (plugin) no encontrado, verificando instalación de docker-compose-plugin.'
                  sudo apt-get install -y docker-compose-plugin 
              fi
              sudo usermod -aG docker \$(whoami) || true
              newgrp docker || true 
              echo 'Instalación de Docker/Docker Compose completada.'
            "

      - name: Copiar docker-compose.prod.yml y certificados a la instancia
        run: |
          # Se eliminan los flags SSH explícitos para gcloud compute scp,
          # ya que gcloud compute config-ssh debería manejar la configuración SSH.
          gcloud compute scp docker-compose.prod.yml cert/ \
                              ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }}:~/ \
                              --zone=${{ env.GCE_ZONE }} \
                              --project=${{ env.PROJECT_ID }} \
                              --recurse
          echo "Archivos copiados a la instancia."

      - name: Actualizar docker-compose.prod.yml y desplegar en la instancia
        run: |
          gcloud compute ssh ${{ env.SSH_USER }}@${{ env.GCE_INSTANCE_NAME }} \
            --zone=${{ env.GCE_ZONE }} \
            --project=${{ env.PROJECT_ID }} \
            --ssh-flag="-o StrictHostKeyChecking=no" \
            --ssh-flag="-o UserKnownHostsFile=/dev/null" \
            --command="
              cd ~/ && \
              sed -i \"s|__IMAGE_TAG__|${{ env.IMAGE_TAG }}|g\" docker-compose.prod.yml && \
              gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet && \
              echo 'Desplegando la aplicación con docker compose...'
              docker compose -f docker-compose.prod.yml down -v --rmi all || true && \
              docker compose -f docker-compose.prod.yml pull && \
              docker compose -f docker-compose.prod.yml up -d
              echo 'Despliegue completado.'
            "